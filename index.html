<script>
    // ... (Behalte die restlichen Variablen wie notes, scaleIntervals, genreRules, structure bei) ...

    let lastMidiBlobUrl = null;

    // --- DEINE BESTEHENDE GENERATE FUNKTION ---
    function generate() {
        // ... (Dein bisheriger Code für die Text-Generierung) ...
        
        // Füge am Ende der generate() Funktion dies hinzu, 
        // um den Drag-Vorgang vorzubereiten:
        prepareDrag();
    }

    // --- NEUE FUNKTION: BEREITET DEN DRAG-VORGANG VOR ---
    function prepareDrag() {
        const dragHandle = document.getElementById('drag-handle');
        
        dragHandle.addEventListener('dragstart', (e) => {
            if (!lastProgression.length) {
                alert("Bitte erst generieren!");
                e.preventDefault();
                return;
            }

            // MIDI-Daten erzeugen
            const midiData = createMidi(lastProgression);
            const blob = new Blob([new Uint8Array(midiData)], {type: 'audio/midi'});
            
            // Falls schon eine URL existiert, löschen (Speichermanagement)
            if (lastMidiBlobUrl) URL.revokeObjectURL(lastMidiBlobUrl);
            
            lastMidiBlobUrl = URL.createObjectURL(blob);
            const fileName = "progression.mid";
            
            // Der entscheidende Trick für den DAW-Drag:
            const downloadURL = `audio/midi:${fileName}:${lastMidiBlobUrl}`;
            e.dataTransfer.setData("DownloadURL", downloadURL);
            e.dataTransfer.setData("text/plain", fileName);
        });
    }

    // --- DEINE BESTEHENDE CREATE-MIDI FUNKTION ---
    function createMidi(prog) {
        const ticksPerQuarter = 480;
        let header = [0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x01, 0xE0];
        let trackData = [];
        trackData.push(0x00, 0xFF, 0x51, 0x03, 0x07, 0xA1, 0x20); // 120 BPM

        prog.forEach(chord => {
            let midiNotes = chord.offsets.map(o => chord.rootIdx + o + 48);
            midiNotes.forEach((n, i) => {
                trackData.push(i === 0 ? 0x00 : 0x00); 
                trackData.push(0x90, n, 0x60); 
            });
            let duration = ticksPerQuarter * 4; 
            trackData.push(...encodeVarInt(duration));
            midiNotes.forEach((n, i) => {
                trackData.push(i === 0 ? 0x00 : 0x00); 
                trackData.push(0x80, n, 0x00); 
            });
        });

        trackData.push(0x00, 0xFF, 0x2F, 0x00);
        let trackHeader = [0x4D, 0x54, 0x72, 0x6B, ...encodeLength(trackData.length)];
        return header.concat(trackHeader, trackData);
    }

    // Hilfsfunktionen (VarInt / Length) wie vorher...
    function encodeVarInt(v) {
        let buffer = [v & 0x7F];
        while (v >>= 7) buffer.push((v & 0x7F) | 0x80);
        return buffer.reverse();
    }
    function encodeLength(len) {
        return [(len >> 24) & 0xFF, (len >> 16) & 0xFF, (len >> 8) & 0xFF, len & 0xFF];
    }

    // ... (Der Rest deiner Funktionen: copyText, addBlock, renderStructure etc.) ...
</script>
